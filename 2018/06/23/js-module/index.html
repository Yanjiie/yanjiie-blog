<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="偶然的一个周末复习了一下 JS 的模块标准，刷新了一下对 JS 模块化的理解。"><meta name="keywords" content="JavaScript"><meta property="og:type" content="article"><meta property="og:title" content="探索 JS 中的模块化"><meta property="og:url" content="http://yanjiie.me/2018/06/23/js-module/index.html"><meta property="og:site_name" content="Zoro"><meta property="og:description" content="偶然的一个周末复习了一下 JS 的模块标准，刷新了一下对 JS 模块化的理解。"><meta property="og:locale" content="zh-cn"><meta property="og:image" content="http://yanjiie.me/img/js-module/js-module.png"><meta property="og:image" content="http://yanjiie.me/img/js-module/older-project.png"><meta property="og:updated_time" content="2018-06-28T08:47:16.012Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="探索 JS 中的模块化"><meta name="twitter:description" content="偶然的一个周末复习了一下 JS 的模块标准，刷新了一下对 JS 模块化的理解。"><meta name="twitter:image" content="http://yanjiie.me/img/js-module/js-module.png"><link rel="shortcut icon" href="/favicon.png"><link rel="icon" type="image/png" href="/img/logo.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/img/logo.png"><title>探索 JS 中的模块化</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/rtl.css"></head><body class="max-width mx-auto px3 ltr"><div id="header-post"><a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")' style="display:none"><i class="fas fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Writing</a></li><li><a href="http://github.com/Yanjiie">Projects</a></li><li><a href="/categories/生活">Lifestyle</a></li><li><a href="/categories/技术">Technology</a></li><li><a href="/about/">Who Am I</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="/2018/02/22/2018-Flags/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle()' onmouseout='$("#i-next").toggle()'></i></a></li><li><a class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fas fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id="i-prev" class="info" style="display:none">Previous post</span> <span id="i-next" class="info" style="display:none">Next post</span> <span id="i-top" class="info" style="display:none">Back to top</span> <span id="i-share" class="info" style="display:none">Share post</span></span><br><div id="share" style="display:none"><ul><li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yanjiie.me/2018/06/23/js-module/"><i class="fab fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=http://yanjiie.me/2018/06/23/js-module/&text=探索 JS 中的模块化"><i class="fab fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yanjiie.me/2018/06/23/js-module/&title=探索 JS 中的模块化"><i class="fab fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yanjiie.me/2018/06/23/js-module/&is_video=false&description=探索 JS 中的模块化"><i class="fab fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=探索 JS 中的模块化&body=Check out this article: http://yanjiie.me/2018/06/23/js-module/"><i class="fas fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=http://yanjiie.me/2018/06/23/js-module/&title=探索 JS 中的模块化"><i class="fab fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=http://yanjiie.me/2018/06/23/js-module/&title=探索 JS 中的模块化"><i class="fab fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yanjiie.me/2018/06/23/js-module/&title=探索 JS 中的模块化"><i class="fab fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=http://yanjiie.me/2018/06/23/js-module/&title=探索 JS 中的模块化"><i class="fab fa-digg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yanjiie.me/2018/06/23/js-module/&name=探索 JS 中的模块化&description=&lt;blockquote&gt;&lt;p&gt;偶然的一个周末复习了一下 JS 的模块标准，刷新了一下对 JS 模块化的理解。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&#34;/img/js-module/js-module.png&#34; alt=&#34;JS Module&#34;&gt;&lt;/p&gt;"><i class="fab fa-tumblr" aria-hidden="true"></i></a></li></ul></div><div id="toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#发展过程"><span class="toc-number">1.</span> <span class="toc-text">发展过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CommonJS-规范"><span class="toc-number">2.</span> <span class="toc-text">CommonJS 规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AMD-规范（Asynchromous-Module-Definition）"><span class="toc-number">3.</span> <span class="toc-text">AMD 规范（Asynchromous Module Definition）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMD-规范（Common-Module-Definition）"><span class="toc-number">4.</span> <span class="toc-text">CMD 规范（Common Module Definition）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES-Module"><span class="toc-number">5.</span> <span class="toc-text">ES Module</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></span></div><div class="content index my4"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">探索 JS 中的模块化</h1><div class="meta"><span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">蓝小胖</span></span><div class="postdate"><time datetime="2018-06-23T02:15:59.000Z" itemprop="datePublished">2018-06-23</time></div><div class="article-tag"><i class="fas fa-tag"></i> <a class="tag-link" href="/tags/JavaScript/">JavaScript</a></div></div></header><div class="content" itemprop="articleBody"><blockquote><p>偶然的一个周末复习了一下 JS 的模块标准，刷新了一下对 JS 模块化的理解。</p></blockquote><p><img src="/img/js-module/js-module.png" alt="JS Module"></p><a id="more"></a><p>从开始 Coding 以来，总会周期性地突发奇想进行 Code Review。既是对一段时期的代码进行总结，也是对那一段时光的怀念。</p><p>距离上一次 Review 已经过去近两个月，这次竟然把两年前在源续写的代码翻了出来，代码杂乱无章的程度就像那时更加浮躁的自己，让人感慨时光流逝之快。</p><p>话不多说，直接上码。</p><p>当时在做的是一个境外电商项目(<a href="http://www.thanbach.com" target="_blank" rel="noopener">越南天宝商城</a>)，作为非 CS 的新手程序员，接触 Coding 时间不长和工程化观念不强，在当时的项目中出现了这样的代码：</p><p><em>import.js:</em><br><img src="/img/js-module/older-project.png" alt="import.js"></p><p>这段代码看起来就是不断地从 DOM 中插进 CSS 和 JS，虽然写得很烂，但是很能反映以前的 Web 开发方式。</p><p>在 Web 开发中，有一个原则叫“关注点分离(separation of concerns)“，意思是各种技术只负责自己的领域，不互相耦合混合在一起，所以催生出了 HTML、CSS 和 JavaScript。</p><p>其中，在 Web 中负责逻辑和交互 的 JavaScript，是一门只用 10 天设计出来的语言，虽然借鉴了许多优秀静态和动态语言的优点，但却一直没有模块 ( module ) 体系。这导致了它将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 <code>Ruby</code> 的 <code>require</code>、<code>Python</code> 的 <code>import</code>，甚至就连 <code>CSS</code> 都有 <code>@import</code>，但是 JavaScript 任何这方面的支持都没有。而且 JS 是一种加载即运行的技术，在页面中插入脚本时还需要考虑库的依赖，JS 在这方面的缺陷，对开发大型的、复杂的项目形成了巨大障碍。</p><h2 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h2><p>虽然 JS 本身并不支持模块化，但是这并不能阻挡 JS 走向模块化的道路。既然本身不支持，那么就从代码层面解决问题。活跃的社区开始制定了一些模块方案，其中最主要的是 CommonJS 和 AMD，ES6 规范出台之后，以一种更简单的形式制定了 JS 的模块标准 (ES Module)，并融合了 CommonJS 和 AMD 的优点。</p><p><strong>大致的发展过程：</strong></p><p><em>CommonJS(服务端)</em> =&gt; <em>AMD (浏览器端)</em> =&gt; <em>CMD / UMD</em> =&gt; <em>ES Module</em></p><h2 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h2><p>2009年，Node.js 横空出世，JS 得以脱离浏览器运行，我们可以使用 JS 来编写服务端的代码了。对于服务端的 JS，没有模块化简直是不能忍。</p><p>CommonJs (前 ServerJS) 在这个阶段应运而生，制定了 <a href="http://wiki.commonjs.org/wiki/Modules/1.0" target="_blank" rel="noopener">Module/1.0 规范</a>，定义了第一版模块标准。</p><p><strong>标准内容：</strong></p><ol><li>模块通过变量 <code>exports</code> 来向外暴露 API，<code>exports</code> 只能是一个对象，暴露的 API 须作为此对象的属性。</li><li>定义全局函数 <code>require</code>，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴露出来的 API。</li><li>如果被 <code>require</code> 函数引入的模块中也包含依赖，那么依次加载这些依赖。</li></ol><p><strong>特点：</strong></p><ol><li>模块可以多次加载，首次加载的结果将会被缓存，想让模块重新运行需要清除缓存。</li><li>模块的加载是一项阻塞操作，也就是同步加载。</li></ol><p>它的语法看起来是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  moduleFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">exports.moduleFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 b.js 中引用</span></span><br><span class="line"><span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'a.js'</span>);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">var</span> moduleFunc = <span class="built_in">require</span>(<span class="string">'a.js'</span>).moduleFunc;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(moduleA.moduleFunc());</span><br><span class="line"><span class="built_in">console</span>.log(moduleFunc())</span><br></pre></td></tr></table></figure><h2 id="AMD-规范（Asynchromous-Module-Definition）"><a href="#AMD-规范（Asynchromous-Module-Definition）" class="headerlink" title="AMD 规范（Asynchromous Module Definition）"></a>AMD 规范（Asynchromous Module Definition）</h2><p>CommonJS 规范出现后，在 Node 开发中产生了非常良好的效果，开发者希望借鉴这个经验来解决浏览器端 JS 的模块化。</p><p>但大部分人认为浏览器和服务器环境差别太大，毕竟浏览器端 JS 是通过网络动态依次加载的，而不是像服务端 JS 存在本地磁盘中。因此，浏览器需要实现的是异步模块，模块在定义的时候就必须先指明它所需要依赖的模块，然后把本模块的代码写在回调函数中去执行，最终衍生出了 <a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD 规范</a>。</p><p>AMD 的主要思想是异步模块，主逻辑在回调函数中执行，这和浏览器前端所习惯的开发方式不谋而合，<a href="http://requirejs.org/" target="_blank" rel="noopener">RequireJS</a> 应运而生。</p><p><strong>标准内容：</strong></p><ol><li>用全局函数 <code>define</code> 来定义模块，用法为：<code>define(id?, dependencies?, factory)</code>;</li><li>id 为模块标识，遵从 CommonJS Module Identifiers 规范</li><li>dependencies 为依赖的模块数组，在 factory 中需传入形参与之一一对应，如果 dependencies 省略不写，则默认为 <code>[&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]</code> ，factory 中也会默认传入 require, exports, module，与 ComminJS 中的实现保持一致</li><li>如果 factory 为函数，模块对外暴露 API 的方法有三种：return 任意类型的数据、exports.xxx = xxx 或 module.exports = xxx</li><li>如果 factory 为对象，则该对象即为模块的返回值</li></ol><p><strong>特点：</strong></p><ol><li>前置依赖，异步加载</li><li>便于管理模块之间的依赖性，有利于代码的编写和维护。</li></ol><p>它的用法看起来是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a.js'</span>);</span><br><span class="line">  exports.name = <span class="string">'Jack'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'b.js'</span>);</span><br><span class="line">  exports.desc = <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">moduleA, moduleB</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'main.js'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(moduleA.name + <span class="string">', '</span> + moduleB.desc);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行顺序：</span></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="comment">// main.js</span></span><br></pre></td></tr></table></figure><p>人无完人，AMD/RequireJS 也存在饱受诟病的缺点。按照 AMD 的规范，在定义模块的时候需要把所有依赖模块都罗列一遍（前置依赖），而且在使用时还需要在 factory 中作为形参传进去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d, e, f, g</span>)</span>&#123; ..... &#125;);</span><br></pre></td></tr></table></figure><p>看起来略微不爽 …</p><p>RequireJS 模块化的顺序是这样的：<code>模块预加载 =&gt; 全部模块预执行 =&gt; 主逻辑中调用模块</code>，所以实质是依赖加载完成后还会预先一一将模块执行一遍，这种方式会使得程序效率有点低。</p><p>所以 RequireJS 也提供了就近依赖，会在执行至 require 方法才会去进行依赖加载和执行，但这种方式的用户体验不是很好，用户的操作会有明显的延迟（下载依赖过程），虽然可以通过各种 loading 去解决。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 就近依赖</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>([<span class="string">'a'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">moduleA</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(moduleA.name);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="CMD-规范（Common-Module-Definition）"><a href="#CMD-规范（Common-Module-Definition）" class="headerlink" title="CMD 规范（Common Module Definition）"></a>CMD 规范（Common Module Definition）</h2><p>AMD/RequireJS 的 JS 模块实现上有很多不优雅的地方，长期以来在开发者中广受诟病，原因主要是不能以一种更好的管理模块的依赖加载和执行，虽然有不足的地方，但它提出的思想在当时是非常先进的。</p><p>既然优缺点那么必然有人出来完善它，<a href="https://seajs.github.io/seajs/docs/" target="_blank" rel="noopener">SeaJS</a> 在这个时候出现。</p><p>SeaJS 遵循的是 <a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank" rel="noopener">CMD 规范</a>，CMD 是在 AMD 基础上改进的一种规范，解决了 AMD 对依赖模块的执行时机处理问题。</p><p>SeaJS 模块化的顺序是这样的：<code>模块预加载 =&gt; 主逻辑调用模块前才执行模块中的代码</code>，通过依赖的延迟执行，很好解决了 RequireJS 被诟病的缺点。</p><p>SeaJS 用法和 AMD 基本相同，并且融合了 CommonJS 的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a.js'</span>);</span><br><span class="line">  exports.name = <span class="string">'Jack'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'main.js'</span>);</span><br><span class="line">  <span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'a'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(moduleA.name);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行顺序</span></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="comment">// a.js</span></span><br></pre></td></tr></table></figure><p>除此之外，SeaJS 还提供了 async API，实现依赖的延迟加载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> moduleA = <span class="built_in">require</span>.async(<span class="string">'a'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(moduleA.name);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>SeaJS 的出现，貌似以一种比较完美的形式解决了 JS 模块化的问题，是 CommonJS 在浏览器端的践行者，并吸收了 RequestJS 的优点。</p><h2 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h2><p><strong>ES Module 是目前 web 开发中使用率最高的模块化标准。</strong></p><p>随着 JS 模块化开发的呼声越来越高，作为 JS 语言规范的官方组织 ECMA 也开始将 JS 模块化纳入 TC39 提案中，并在 ECMAScript 6.0 中得到实践。</p><p>ES Module 吸收了其他方案的优点并以更优雅的形式实现模块化，它的思想是尽量的静态化，即在编译时就确定所有模块的依赖关系，以及输入和输出的变量，和 CommonJS 和 AMD/CMD 这些标准不同的是，它们都是在运行时才能确定需要依赖哪一些模块并且执行它。ES Module 使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，实现一些只能靠静态分析实现的功能（比如引入宏（macro）和类型检验（type system）。</p><p><strong>标准内容：</strong></p><ol><li>模块功能主要由两个命令构成：<code>export</code> 和 <code>import</code>。<code>export</code> 命令用于规定模块的对外接口，<code>import</code> 命令用于输入其他模块提供的功能。</li><li>通过 <code>export</code> 命令定义了模块的对外接口，其他 JS 文件就可以通过 <code>import</code> 命令加载这个模块。</li></ol><p>ES Module 可以有多种用法：</p><p><strong>模块的定义：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * export 只支持对象形式导出，不支持值的导出，export default 命令用于指定模块的默认输出，</span></span><br><span class="line"><span class="comment"> * 只支持值导出，但是只能指定一个，本质上它就是输出一个叫做 default 的变量或方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 写法 1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 写法 2</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; m &#125;;</span><br><span class="line"><span class="comment">// 写法 3</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; n <span class="keyword">as</span> m &#125;;</span><br><span class="line"><span class="comment">// 写法 4</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> n;</span><br></pre></td></tr></table></figure><p><strong>模块的引入：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构引入</span></span><br><span class="line"><span class="keyword">import</span> &#123; firstName, lastName, year &#125; <span class="keyword">from</span> <span class="string">'a-module'</span>;</span><br><span class="line"><span class="comment">// 为输入的变量重新命名</span></span><br><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">'a-module'</span>;</span><br><span class="line"><span class="comment">// 引出模块对象（引入所有）</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ModuleA <span class="keyword">from</span> <span class="string">'a-module'</span>;</span><br></pre></td></tr></table></figure><p>在使用 ES Module 值得注意的是：<code>import</code> 和 <code>export</code> 命令只能在模块的顶层，在代码块中将会报错，这是因为 ES Module 需要在编译时期进行模块静态优化，<code>import</code> 和 <code>export</code> 命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行，这种设计有利于编译器提高效率，但也导致无法在运行时加载模块（动态加载）。</p><p>对于这个缺点，TC39 有了一个新的提案 – <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">Dynamic Import</a>，提案的内容是建议引入 <code>import()</code> 方法，实现模块动态加载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// specifier: 指定所要加载的模块的位置</span></span><br><span class="line"><span class="keyword">import</span>(specifier)</span><br></pre></td></tr></table></figure><p><code>import()</code> 方法返回的是一个 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'b-module'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.helloWorld();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.message);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><code>import()</code> 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code> 函数与所加载的模块没有静态连接关系，这点也是与 <code>import</code> 语句不相同。<code>import()</code> 类似于 Node 的 <code>require</code> 方法，区别主要是前者是异步加载，后者是同步加载。</p><p>通过 <code>import</code> 和 <code>export</code> 命令以及 <code>import()</code> 方法，ES Module 几乎实现了 CommonJS/AMD/CMD 方案的所有功能，更重要的是它是作为 ECMAScript 标准出现的，带有正统基因，这也是它在现在 Web 开发中广泛应用的原因之一。</p><p>但 ES Module 是在 ECMAScript 6.0 标准中的，而目前绝大多数的浏览器并直接支持 ES6 语法，ES Module 并不能直接使用在浏览器上，所以需要 Babel 先进行转码，将 import 和 export 命令转译成 ES2015 语法才能被浏览器解析。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JS 模块化的出现使得前端工程化程度越来越高，让使用 JS 开发大型应用成为触手可及的现实（VScode）。纵观 JS 模块化的发展，其中很多思想都借鉴了其他优秀的动态语言（Python），然后结合 JS 运行环境的特点，衍生出符合自身的标准。但其实在本质上，浏览器端的 JS 仍没有真正意义上的支持模块化，只能通过工具库（RequireJS、SeaJS）或者语法糖（ES Module）去 Hack 实现模块化。随着 Node 前端工程化工具的繁荣发展（Grunt/Gulp/webpack），使我们可以不关注模块化的实现过程，直接享受 JS 模块化编程的快感。</p><p>在复习 JS 模块化的过程中，对 Webpack 等工具的模块化语法糖转码产生了新的兴趣，希望有时间可以去分析一下模块化的打包机制和转译代码，然后整理出来加深一下自己对模块化实现原理的认识和理解。</p><p>期待下一篇。</p><p><strong>参考文章：</strong></p><ul><li><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">ECMAScript 6 入门 – 阮一峰</a></li><li><a href="https://www.cnblogs.com/lvdabao/p/js-modules-develop.html" target="_blank" rel="noopener">JS 模块化历程</a></li></ul></div></article></div><div id="footer-post-container"><div id="footer-post"><div id="nav-footer" style="display:none"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Writing</a></li><li><a href="http://github.com/Yanjiie">Projects</a></li><li><a href="/categories/生活">Lifestyle</a></li><li><a href="/categories/技术">Technology</a></li><li><a href="/about/">Who Am I</a></li></ul></div><div id="toc-footer" style="display:none"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#发展过程"><span class="toc-number">1.</span> <span class="toc-text">发展过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CommonJS-规范"><span class="toc-number">2.</span> <span class="toc-text">CommonJS 规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AMD-规范（Asynchromous-Module-Definition）"><span class="toc-number">3.</span> <span class="toc-text">AMD 规范（Asynchromous Module Definition）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMD-规范（Common-Module-Definition）"><span class="toc-number">4.</span> <span class="toc-text">CMD 规范（Common Module Definition）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES-Module"><span class="toc-number">5.</span> <span class="toc-text">ES Module</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div><div id="share-footer" style="display:none"><ul><li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yanjiie.me/2018/06/23/js-module/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=http://yanjiie.me/2018/06/23/js-module/&text=探索 JS 中的模块化"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yanjiie.me/2018/06/23/js-module/&title=探索 JS 中的模块化"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yanjiie.me/2018/06/23/js-module/&is_video=false&description=探索 JS 中的模块化"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=探索 JS 中的模块化&body=Check out this article: http://yanjiie.me/2018/06/23/js-module/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=http://yanjiie.me/2018/06/23/js-module/&title=探索 JS 中的模块化"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=http://yanjiie.me/2018/06/23/js-module/&title=探索 JS 中的模块化"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yanjiie.me/2018/06/23/js-module/&title=探索 JS 中的模块化"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=http://yanjiie.me/2018/06/23/js-module/&title=探索 JS 中的模块化"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yanjiie.me/2018/06/23/js-module/&name=探索 JS 中的模块化&description=&lt;blockquote&gt;&lt;p&gt;偶然的一个周末复习了一下 JS 的模块标准，刷新了一下对 JS 模块化的理解。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&#34;/img/js-module/js-module.png&#34; alt=&#34;JS Module&#34;&gt;&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li></ul></div><div id="actions-footer"><a id="menu" class="icon" href="#" onclick='return $("#nav-footer").toggle(),!1'><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a> <a id="toc" class="icon" href="#" onclick='return $("#toc-footer").toggle(),!1'><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a><a id="top" style="display:none" class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></div></div></div><footer id="footer"><div class="footer-left">Copyright &copy; 2018 Yanjiie</div></footer></body></html><link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css"><script src="/lib/jquery/jquery.min.js"></script><script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script><script>FontAwesomeConfig={searchPseudoElements:!0}</script><script src="https://use.fontawesome.com/releases/v5.0.8/js/all.js" data-auto-replace-svg="nest"></script><script src="/js/main.js"></script>