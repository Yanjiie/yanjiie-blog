<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蓝小胖的博客 | sunsky6&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sunsky6.me/"/>
  <updated>2018-02-22T07:08:44.674Z</updated>
  <id>http://sunsky6.me/</id>
  
  <author>
    <name>蓝小胖</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018 Flags</title>
    <link href="http://sunsky6.me/2018/2018-Flags/"/>
    <id>http://sunsky6.me/2018/2018-Flags/</id>
    <published>2018-02-22T05:45:17.000Z</published>
    <updated>2018-02-22T07:08:44.674Z</updated>
    
    <content type="html"><![CDATA[<p>给自己立下 2018 的目标。<br><img src="/img/2018.jpg" alt="2018-flags"></p><a id="more"></a><p>今天是大年初七，各行各业都在今天陆陆续续开工了。为了多陪伴父母两天时间和避开返程的高峰，节后我选择了继续休假。</p><p>一年之计在于春，应初七开工的这个日子，定下在接下来的一年里自己的一些计划和目标：</p><h1 id="Past"><a href="#Past" class="headerlink" title="Past"></a>Past</h1><p>2017 一年中经历了许多风雨，双足迈出象牙塔；</p><p>从创业团队–源续离开，经历了磕磕碰碰的求职，最后在魅族重新落了脚；</p><p>Title 从「伪全栈工程师」变成了「前端工程师」，不再像在创业团队一样身兼多向开发，静下心沉淀于自己喜欢的前端。对于非 CS 科班出身的自己来说，这是很符合自己的发展规划的；</p><p>在 11 月收获了一份与灵魂呼应的喜悦。</p><h1 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h1><p>2018，希望自己完成这些目标：</p><h2 id="团队业务的开发"><a href="#团队业务的开发" class="headerlink" title="团队业务的开发"></a>团队业务的开发</h2><ul><li>完善 Flyme 组件库的开发，争取在年中发布开源版本（0/100%）</li><li>完善契合团队 Weex SDK 的脚手架，增加更多的功能（0/100%）</li><li>从零开发前后端分离的后台管理系统脚手架，目标是完成一个可用的版本（0/100%）</li></ul><h2 id="增大在社区中的影响力"><a href="#增大在社区中的影响力" class="headerlink" title="增大在社区中的影响力"></a>增大在社区中的影响力</h2><ul><li>2018 全年至少产出文章 12 篇（0/100%）</li><li>全年至少进行 3 场组以上的技术分享，逐渐营造好的团队技术氛围（0/100%）</li><li>持续参与 Weex 相关开源仓库的构建，提交优秀代码</li><li>开源 Flyme 组件库，使团队在 Weex 中拥有更大的影响力</li></ul><h2 id="持续扎实基本功"><a href="#持续扎实基本功" class="headerlink" title="持续扎实基本功"></a>持续扎实基本功</h2><ul><li>《鸟哥的 Linux 私房菜》（0/100%）</li><li>《深入理解计算机操作系统》（0/100%）</li><li>《CSS 权威指南》、《CSS 揭秘》（0/100%）</li><li>《深入浅出 NodeJS》、《NodeJS 硬实战》、《Security Your NodeJS Application》（0/100%）</li><li>《深入理解 JavaScript》（0/100%）</li></ul><h2 id="增强敏捷开发的实践经验"><a href="#增强敏捷开发的实践经验" class="headerlink" title="增强敏捷开发的实践经验"></a>增强敏捷开发的实践经验</h2><ul><li>合理的团队沟通</li><li>清晰的文档输出</li><li>优秀的代码质量</li><li>稳定交付</li><li>版本快速迭代</li></ul><h2 id="技术方向衍生"><a href="#技术方向衍生" class="headerlink" title="技术方向衍生"></a>技术方向衍生</h2><ul><li>重新学习小程序开发，感受特性，参与开源社区的讨论</li><li>学习 Python，感受机器学习</li></ul><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul><li>和 🐑 进行一次长途旅行</li><li>和 🐑 进行一次短途旅行</li><li>理财增值率达到 6%</li></ul><p>以上是自己立下的关于 2018 的一些 flags，遵循周期 Review 并同步进度。</p><p>Keep moving.</p><p>God help those who help themselves.</p><p>共勉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给自己立下 2018 的目标。&lt;br&gt;&lt;img src=&quot;/img/2018.jpg&quot; alt=&quot;2018-flags&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在 Weex 中使用国际化</title>
    <link href="http://sunsky6.me/2018/%E5%9C%A8-Weex-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    <id>http://sunsky6.me/2018/在-Weex-中使用国际化/</id>
    <published>2018-01-12T02:35:30.000Z</published>
    <updated>2018-02-22T05:36:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在-weex-中使用国际化"><a href="#在-weex-中使用国际化" class="headerlink" title="在 weex 中使用国际化"></a>在 weex 中使用国际化</h1><p>Weex 是一套使用 <code>Vue.js</code> 作为上层框架的简单易用的跨平台开发方案，遵循 W3C 标准实现了统一的 <code>JSEngine</code> 和 <code>DOM API</code>，能使用一套代码打造 Web、Android、iOS 三个平台的原生应用。</p><p>对于面向多地区用户的 App 来说，应用的国际化是不可缺少的需求，在 <code>Android</code> 和 <code>iOS</code> 平台中，都拥有成熟的国际化方案。</p><p>而目前，Weex 团队并没有提供国际化相关的方案，但幸运的是，Weex 使用了 <code>Vue.js</code> 作为上层框架，我们可以在 <code>Vue.js</code> 生态中寻找相关的解决方案。经过一段时间了解，寻找到了一些国际化的解决方案，结合了 <code>Weex</code> 的一些特性，设想了一些可选择的国际化提案。</p><a id="more"></a><p>本文分下面几部分：</p><ol><li>Vue.js 国际化方案 – Vue-i18n</li><li>基于语言文件引入的国际化方案</li><li>基于 Weex 的 <code>JS Service</code> 实现国际化的方案</li></ol><h1 id="Vue-js-国际化方案"><a href="#Vue-js-国际化方案" class="headerlink" title="Vue.js 国际化方案"></a>Vue.js 国际化方案</h1><p>众所周知，Vue.js 以其文档和生态的完整性著称。发展得如火如荼的 Vue 社区中，不乏优秀的开源作者。其中 <a href="https://github.com/kazupon/vue-i18n" target="_blank" rel="noopener">Vue-i18n</a> 是一款颇有人气的开源国际化插件，目前在 github 中 star 数已经 1.9k，许多国内外项目都兼容了这款插件，其中也包括 <a href="http://element.eleme.io/#/zh-CN" target="_blank" rel="noopener">ElementUI</a>。</p><p>Vue-i18n 是以插件的形式配合 Vue 进行工作的。通过全局的 mixin 的方式将插件提供的方法挂载到Vue的实例上。</p><h2 id="Vue-i18n-的基本使用"><a href="#Vue-i18n-的基本使用" class="headerlink" title="Vue-i18n 的基本使用"></a>Vue-i18n 的基本使用</h2><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install vue-i18n -D</span><br></pre></td></tr></table></figure><h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p><strong>入口文件 index.js</strong>:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VueI18n <span class="keyword">from</span> <span class="string">'vue-i18n'</span></span><br><span class="line"><span class="keyword">var</span> App = <span class="built_in">require</span>(<span class="string">'./index.vue'</span>)</span><br><span class="line"></span><br><span class="line">Vue.use(VueI18n)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 国际化的内容</span></span><br><span class="line"><span class="keyword">const</span> messages = &#123;</span><br><span class="line">  en: &#123;</span><br><span class="line">    message: &#123;</span><br><span class="line">      <span class="string">'hello'</span>: <span class="string">'hello world'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ja: &#123;</span><br><span class="line">    message: &#123;</span><br><span class="line">      <span class="string">'hello'</span>: <span class="string">'こんにちは、世界'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置参数，创建 Vuei18n 的实例。</span></span><br><span class="line"><span class="keyword">const</span> i18n = <span class="keyword">new</span> VueI18n(&#123;</span><br><span class="line">  locale: <span class="string">'ja'</span>, <span class="comment">// set locale</span></span><br><span class="line">  messages, <span class="comment">// set locale messages</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Vuei18n 的实例 i18n，创建 Vue 的实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  i18n,</span><br><span class="line">  el: <span class="string">'#root'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>.Vue 单文件中</strong>:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>&#123;&#123; $t("message.hello") &#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>切换语言</strong>:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;&#125;),</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeLanguage() &#123;</span><br><span class="line">            <span class="keyword">this</span>.$i18n.locale = <span class="string">'cn'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Vue-i18n-在-Weex-中使用"><a href="#Vue-i18n-在-Weex-中使用" class="headerlink" title="Vue-i18n 在 Weex 中使用"></a>Vue-i18n 在 Weex 中使用</h2><p>Vue-i18n 作为目前 Vue SPA 的国际化首选插件，<strong>优点</strong>显而易见：</p><ol><li>使用方便快捷</li><li>单次注入，全局使用</li><li>国际化内容可动态加载与语言切换</li><li><p>还支持单文件组件以块的形式定义国际化内容：</p> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 需要 @kazupon/vue-i18n-loader 支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i18n</span>&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">  "en": &#123;</span><br><span class="line">    "hello": "hello world!"</span><br><span class="line">  &#125;,</span><br><span class="line">  "ja": &#123;</span><br><span class="line">    "hello": "こんにちは、世界！"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">i18n</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>缺点</strong>:</p><p>由于 Weex 仅使用 Vue.js 的 runtime 版本作为上层框架，在 webpack 打包的过程中，H5 和 Native 所使用的 loader 并不相同。</p><p>H5 使用的是 Vue-loader，可以通过配置 options 来自定义单文件标签库内容的编译。使用方法： <a href="https://vue-loader.vuejs.org/en/configurations/custom-blocks.html" target="_blank" rel="noopener">Custom Block</a></p><p>而</p><blockquote><p>Native 使用的是 weex-loader，目前不支持自定义块的编译。</p></blockquote><p>因为 loader 的不同，目前 Weex Native 不支持在单文件组件内使用块形式使用 Vue-i18n，所以国际化不能就近管理。</p><p>除了因为 loader 的不同，Vue-i18n 的部分功能受到了限制，Vue-i18n 在 Weex 中使用还存在其他的问题。</p><p>在使用 Vue 开发的 Web App 中，大部分可能都以 SPA 的形式开发，通过单一的入口结合 Router 进行多页面的构建，使得公共的 JS 可以做到一次加载，多页使用。但是在 Weex 的官方文档<a href="https://weex.apache.org/cn/references/vue/difference-with-web.html" target="_blank" rel="noopener">《Vue 2.x 在 Weex 和 Web 中的差异》</a>一文中：</p><blockquote><p>Weex 在原生端使用的是“多页”的实现，不同的 js bundle 将会在不同的原生页面中执行；也就是说，不同的 js bundle 之间将不同共享 js 变量。即使是 Vue 这个变量，在不同页面中也对应了不同的引用。</p></blockquote><p>也就是说 Weex 官方推荐使用多页的形式开发 Weex 应用。虽然 Weex 中也支持 Vue-Router 的使用，但事实上经过项目的考证，在 Weex 中使用多页的形式开发，随着页面的不断增加，单个 ViewController 或 Activity 所使用的内存会变得越来越多，最终导致应用崩溃，而且页面跳转也不支持动画过渡，造成的用户体验也不好。</p><p>由于 Weex 使用多页开发的这个约束，使得 Vue 现有的插件均不能做到一次引入，全局使用。同样的，如果要在 Weex 中使用 Vue-i18n，需要在每一个页面的入口都在 Vue 实例中注册 VueI8N 对象，并且引入相关代码库。</p><p>经过打包测试</p><blockquote><p>在 Weex 中引入 Vue-i18n，将使最终生成的 JS Bundle 增大 22KB 左右</p></blockquote><p>22KB 无论对于本地还是网络加载 JS Bundle 来说，影响其实都微乎其微。但由于国际化资源文件不能按需加载，在打包时就需要将所有国际化资源引入，而这个缺点，才是增大 JS Bundle 的罪魁祸首。</p><h1 id="基于-Weex-的-JS-Service-实现国际化（待续）"><a href="#基于-Weex-的-JS-Service-实现国际化（待续）" class="headerlink" title="基于 Weex 的 JS Service 实现国际化（待续）"></a>基于 Weex 的 JS Service 实现国际化（待续）</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;在-weex-中使用国际化&quot;&gt;&lt;a href=&quot;#在-weex-中使用国际化&quot; class=&quot;headerlink&quot; title=&quot;在 weex 中使用国际化&quot;&gt;&lt;/a&gt;在 weex 中使用国际化&lt;/h1&gt;&lt;p&gt;Weex 是一套使用 &lt;code&gt;Vue.js&lt;/code&gt; 作为上层框架的简单易用的跨平台开发方案，遵循 W3C 标准实现了统一的 &lt;code&gt;JSEngine&lt;/code&gt; 和 &lt;code&gt;DOM API&lt;/code&gt;，能使用一套代码打造 Web、Android、iOS 三个平台的原生应用。&lt;/p&gt;
&lt;p&gt;对于面向多地区用户的 App 来说，应用的国际化是不可缺少的需求，在 &lt;code&gt;Android&lt;/code&gt; 和 &lt;code&gt;iOS&lt;/code&gt; 平台中，都拥有成熟的国际化方案。&lt;/p&gt;
&lt;p&gt;而目前，Weex 团队并没有提供国际化相关的方案，但幸运的是，Weex 使用了 &lt;code&gt;Vue.js&lt;/code&gt; 作为上层框架，我们可以在 &lt;code&gt;Vue.js&lt;/code&gt; 生态中寻找相关的解决方案。经过一段时间了解，寻找到了一些国际化的解决方案，结合了 &lt;code&gt;Weex&lt;/code&gt; 的一些特性，设想了一些可选择的国际化提案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Weex" scheme="http://sunsky6.me/tags/Weex/"/>
    
  </entry>
  
  <entry>
    <title>Angular React Vue 数据驱动实现方式的区别及性能</title>
    <link href="http://sunsky6.me/2017/Angular%20React%20Vue%20%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E6%80%A7%E8%83%BD/"/>
    <id>http://sunsky6.me/2017/Angular React Vue 数据驱动实现方式的区别及性能/</id>
    <published>2017-12-29T07:05:44.000Z</published>
    <updated>2018-02-22T05:36:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Angular-js-1-的数据驱动实现方式："><a href="#Angular-js-1-的数据驱动实现方式：" class="headerlink" title="Angular.js 1 的数据驱动实现方式："></a>Angular.js 1 的数据驱动实现方式：</h1><h2 id="Angular-使用的是脏检查-Dirty-Check-机制。"><a href="#Angular-使用的是脏检查-Dirty-Check-机制。" class="headerlink" title="Angular 使用的是脏检查( Dirty Check )机制。"></a>Angular 使用的是脏检查( Dirty Check )机制。</h2><p>Angular 视图模板里,读取数据有一个叫 <code>$scope</code> 的上下文,可以就认为它是一个存储数据的JS对象, 里面放了各种视图模板需要访问的数据/函数。<code>$scope</code> 里面的值可以自由更改 (比如说在 Angular 的控制器(Controller)里面)。</p><p>比如说有这样一常简单的 Angular 应用 (模板中引用了 <code>$scope</code> 里的 <code>title</code> 数据, 同时绑定了 <code>onclick</code> 事件修改 <code>title</code> 数据):</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    var testApp = angular.module('testApp', []);</span></span><br><span class="line"><span class="undefined">    testApp.controller('TestController', function ($scope) &#123;</span></span><br><span class="line"><span class="undefined">        $scope.title = 'test title';</span></span><br><span class="line"><span class="undefined">        $scope.onDIVClick = function () &#123;</span></span><br><span class="line"><span class="undefined">            $scope.title = 'another title';</span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-app</span>=<span class="string">"testApp"</span> <span class="attr">ng-controller</span>=<span class="string">"TestController"</span> <span class="attr">ng-click</span>=<span class="string">"onDIVClick()"</span>&gt;</span></span><br><span class="line">    &#123;&#123;title&#125;&#125;  <span class="comment">&lt;!-- 显示为: test title --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>然后点击 div 触发事件, 就会调用 <code>$scope.onDIVClick</code>, 修改了 <code>title</code> 数据, 然后视图就更新了 (内容变为了 <code>another title</code>)。</p><p>==这一步DOM更新是怎么做到的?==</p><p>答案是, Angular 不监听数据更新, 数据发生任何改变时 Angular 都不理睬, 它只是找了一个恰当的时机, 遍历所有的DOM更新方法, 从被修改过任意次的 <code>$scope</code> 数据中尝试更新DO (这里这个”恰当的时机”就是click事件处理结束时)。</p><p><strong>Angular 脏检查实现</strong></p><ul><li>首先, <code>$watch</code>: Angular 在解析视图模板时, 会找出其中的数据绑定, 以及对应的更新DOM的方式, (比如说这里的 <code>Angular React Vue 数据驱动实现方式的区别及性能</code>, 解析出值表达式为 <code>$scope.title</code>, 更新DOM方式为添加表达式的结果到文字内容区), 然后通过 <code>$scope.$watch</code> 将这一绑定注册到当前 <code>$scope</code> 上下文的更新响应操作里</li><li>然后, <code>$apply</code>: 可能更新数据时(比如事件响应函数里), Angular 调用 <code>$scope.$apply(expression)</code> 处理操作函数, <code>$apply(...)</code> 会在处理完成后调用 <code>$scope.$digest()</code></li><li><code>$digest</code>: 在这一函数里, Angular 正式执行数据到视图的查找以及更新操作:<ul><li><code>$digest</code> 每一个循环里会从根作用域( <code>$rootScope</code> )开始(以深度优先方式)遍历所有的 <code>$scope</code> 注册的 <code>$watch</code> 响应操作。对每一个 <code>$watch</code> 响应, 取出数据绑定的值表达式, 求出值, 与上一次的求值作比较, 求值不一样 则取出DOM更新函数, 更新视图</li><li>上一步里, 循环开始时置 <code>dirty = false</code>。只要有任何一个 <code>$watch</code> 响应的值发生了更新, 则当前 <code>$digest</code> 循环置 <code>dirty = true</code></li><li>每次循环结束后, 只要 <code>dirty === true</code> 依然成立, 重新开始新的一轮 <code>$digest</code> 检查循环, 直到 <code>dirty === false</code> (这就是为什么这个实现机制叫做脏检查( Dirty Check ))</li></ul></li></ul><p><strong>脏检查会执行几次?</strong></p><p>即便 $watch 响应里没有更新任何数据, 通常来说脏检查循环也会执行两次, 比如在这个例子里面就是的:</p><ul><li>首先, 在执行 <code>$digest</code> 开始脏检查循环前, click事件触发调用的 <code>onDIVClick</code> 中已经更新了 <code>titl</code>e 数据</li><li>进入第一遍脏检查循环后, <code>Angular React Vue 数据驱动实现方式的区别及性能</code> 对应的 <code>$watch</code> 响应中, 值表达式之前的结果是 <code>&#39;test title&#39;</code>, 现在由于数据已经发生了改变, 新的结果变成了 <code>&#39;another title&#39;</code>, 第一遍循环, <code>dirty</code> 置为 <code>true</code>, 进入下一遍循环</li><li>进入第二便脏检查循环后, 值表达式两次结果均为 <code>&#39;another title&#39;</code>, 没有变化, <code>dirty</code> 为 <code>false</code>。结束脏检查</li></ul><p>所以什么时候脏检查循环只会执行一遍呢? 就是 <code>$apply(...)</code> 处理的操作中没有数据更新操作 (这里描述并不准确, 实际上是否有数据更新跟脏循环执行次数不一定相关, 等会再说)。也就是说, 移除 <code>onDIVClick</code> 里的 <code>title</code> 赋值操作, 脏检查循环就只会执行一次。</p><p>那么, 什么时候脏检查会执行无数次呢? 很简单, 在 <code>$watch</code> 响应的值表达式中中每次都返回新的数据。</p><p>==推荐阅读：==</p><ol><li><a href="http://blog.yunfei.me/blog/angular-dirty-check.html" target="_blank" rel="noopener">Angular 脏检查机制研究</a></li><li><a href="https://github.com/xufei/blog/issues/10" target="_blank" rel="noopener">Angular沉思录（一）数据绑定</a></li></ol><h1 id="Vue-js-的数据驱动实现方式："><a href="#Vue-js-的数据驱动实现方式：" class="headerlink" title="Vue.js 的数据驱动实现方式："></a>Vue.js 的数据驱动实现方式：</h1><h2 id="Vue-使用的是依赖收集。（基础-——-getter-setter）"><a href="#Vue-使用的是依赖收集。（基础-——-getter-setter）" class="headerlink" title="Vue 使用的是依赖收集。（基础 —— getter/setter）"></a>Vue 使用的是依赖收集。（基础 —— getter/setter）</h2><p>同样是实现了双向绑定，但 Vue 使用的方法与 Angular 却完全不同。Vue 的文档中是这样描述的：</p><blockquote><p>把一个普通对象传给 Vue 实例作为它的 data 选项，Vue.js 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。这是 ES5 特性，不能打补丁实现，这便是为什么 Vue.js 不支持 IE8 及更低版本。</p></blockquote><p><code>getter/setter</code> 使得开发者有机会在对象属性取值和赋值的时候进行自定义操作，响应系统便是基于这个特性实现的。</p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p><code>Watcher</code> 是 Vue 核心。每个 <code>Watcher</code> 都拥有一个自己的表达式，<code>Watcher</code> 的作用就是维护这个表达式依赖的数据项，并在数据项更新的时候更新表达式的值。其实从 Vue 的实现来讲，<code>Watcher</code> 应该被叫做 <code>Listener</code>或 <code>Subscriber</code> 更加合适。</p><blockquote><p>模板中每个指令/数据绑定都有一个对应的 watcher 对象，在计算过程中它把属性记录为依赖。之后当依赖的 setter 被调用时，会触发 watcher 重新计算 ，也就会导致它的关联指令更新 DOM。<br><img src="http://cn.vuejs.org/images/data.png" alt=""></p></blockquote><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>依赖收集是通过 <code>property</code> 的 <code>getter</code> 完成的，依赖收集的过程涉及到 Vue 的三类对象：<code>Watcher</code>、<code>Dep</code> 和 <code>Observer</code>。其中 <code>Observer</code> 负责将数据项转化为响应式对象，而 <code>Dep</code> 则用来描述 <code>Watcher</code> 和 <code>Observer</code> 的依赖关系。</p><p>Vue 中，每个 <code>Observer</code> 对应一个 <code>Dep</code> 对象，而每个 <code>Dep</code> 对象可以对应多个 <code>Watcher</code>，每个 <code>Watcher</code> 也可以对应多个 <code>Dep</code> 对象，从而实现了多对多的依赖关系。</p><p>搞清楚了三类对象，下面就来看看依赖关系到底是怎样建立起来的：</p><ol><li>Vue 实例初始化的过程中，首先，每个数据项都会生成一个 <code>Observer</code>，每个 <code>Observer</code> 又会初始化一个 <code>Dep</code> 实例；</li><li>接下来，模板中的每个指令和数据绑定都会生成一个 <code>Watcher</code> 实例，实例化的过程中，会计算这个 <code>Watcher</code> 对应表达式的值；</li><li>计算开始之前，<code>Watcher</code> 会设置 <code>Dep</code> 的静态属性 <code>Dep.target</code> 指向其自身，开始依赖收集；</li><li>计算表达式的过程中，该 <code>Watcher</code> 依赖的数据项会被访问，从而触发其 <code>getter</code> 中的代码；</li><li>数据项 <code>getter</code> 中会判断 <code>Dep.target</code> 是否存在，若存在则将自身的 <code>Dep</code> 实例保存到 <code>Watcher</code> 的列表中，并在此 <code>Dep</code> 实例中注册 <code>Watcher</code> 为订阅者；</li><li>重复上述过程直至 <code>Watcher</code> 计算结束，<code>Dep.target</code> 被清除，依赖收集完成；</li></ol><p>在依赖关系建立后，每当数据项发生变化（<code>setter</code> 被访问），<code>Observer</code> 会调用其 <code>Dep</code> 实例的 <code>notify</code> 方法，在这个 <code>Dep</code> 实例中注册的 <code>Watcher</code> 将会被通知，并重新进行计算及依赖收集的过程，然后执行相应的回调函数。以上就是完成响应的整个过程。</p><p>==推荐阅读：==</p><ol><li><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">Vue官方文档–深入响应式原理</a></li><li><a href="https://zjy.name/archives/vue-reactive-study.html" target="_blank" rel="noopener">Vue 响应式原理探析</a></li><li><a href="https://segmentfault.com/a/1190000011153487" target="_blank" rel="noopener">深入浅出基于“依赖收集”的响应式原理</a></li></ol><h2 id="React-js-的数据驱动实现方式"><a href="#React-js-的数据驱动实现方式" class="headerlink" title="React.js 的数据驱动实现方式"></a>React.js 的数据驱动实现方式</h2><p>React 本质没有双向绑定概念，算法本质是 diff。通过 dom 的抽象化，在 render 时通过比较 vdom 的差异，再使用原生 api patch 到真实 dom 中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Angular-js-1-的数据驱动实现方式：&quot;&gt;&lt;a href=&quot;#Angular-js-1-的数据驱动实现方式：&quot; class=&quot;headerlink&quot; title=&quot;Angular.js 1 的数据驱动实现方式：&quot;&gt;&lt;/a&gt;Angular.js 1 的数据驱动实现方式：&lt;/h1&gt;&lt;h2 id=&quot;Angular-使用的是脏检查-Dirty-Check-机制。&quot;&gt;&lt;a href=&quot;#Angular-使用的是脏检查-Dirty-Check-机制。&quot; class=&quot;headerlink&quot; title=&quot;Angular 使用的是脏检查( Dirty Check )机制。&quot;&gt;&lt;/a&gt;Angular 使用的是脏检查( Dirty Check )机制。&lt;/h2&gt;&lt;p&gt;Angular 视图模板里,读取数据有一个叫 &lt;code&gt;$scope&lt;/code&gt; 的上下文,可以就认为它是一个存储数据的JS对象, 里面放了各种视图模板需要访问的数据/函数。&lt;code&gt;$scope&lt;/code&gt; 里面的值可以自由更改 (比如说在 Angular 的控制器(Controller)里面)。&lt;/p&gt;
&lt;p&gt;比如说有这样一常简单的 Angular 应用 (模板中引用了 &lt;code&gt;$scope&lt;/code&gt; 里的 &lt;code&gt;title&lt;/code&gt; 数据, 同时绑定了 &lt;code&gt;onclick&lt;/code&gt; 事件修改 &lt;code&gt;title&lt;/code&gt; 数据):&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;    var testApp = angular.module(&#39;testApp&#39;, []);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;    testApp.controller(&#39;TestController&#39;, function ($scope) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;        $scope.title = &#39;test title&#39;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;        $scope.onDIVClick = function () &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;            $scope.title = &#39;another title&#39;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-app&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;testApp&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-controller&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;TestController&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-click&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;onDIVClick()&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&amp;#123;title&amp;#125;&amp;#125;  &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 显示为: test title --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://sunsky6.me/tags/JavaScript/"/>
    
  </entry>
  
</feed>
