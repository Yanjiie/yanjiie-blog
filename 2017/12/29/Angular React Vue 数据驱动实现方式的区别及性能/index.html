<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Angular.js 1 的数据驱动实现方式：Angular 使用的是脏检查( Dirty Check )机制。Angular 视图模板里,读取数据有一个叫 $scope 的上下文,可以就认为它是一个存储数据的JS对象, 里面放了各种视图模板需要访问的数据/函数。$scope 里面的值可以自由更改 (比如说在 Angular 的控制器(Controller)里面)。比如说有这样一常简单的 Angu"><meta name="keywords" content="JavaScript"><meta property="og:type" content="article"><meta property="og:title" content="Angular React Vue 数据驱动实现方式的区别及性能"><meta property="og:url" content="http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/index.html"><meta property="og:site_name" content="Zoro"><meta property="og:description" content="Angular.js 1 的数据驱动实现方式：Angular 使用的是脏检查( Dirty Check )机制。Angular 视图模板里,读取数据有一个叫 $scope 的上下文,可以就认为它是一个存储数据的JS对象, 里面放了各种视图模板需要访问的数据/函数。$scope 里面的值可以自由更改 (比如说在 Angular 的控制器(Controller)里面)。比如说有这样一常简单的 Angu"><meta property="og:locale" content="zh-cn"><meta property="og:image" content="http://cn.vuejs.org/images/data.png"><meta property="og:updated_time" content="2018-06-26T06:51:45.119Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Angular React Vue 数据驱动实现方式的区别及性能"><meta name="twitter:description" content="Angular.js 1 的数据驱动实现方式：Angular 使用的是脏检查( Dirty Check )机制。Angular 视图模板里,读取数据有一个叫 $scope 的上下文,可以就认为它是一个存储数据的JS对象, 里面放了各种视图模板需要访问的数据/函数。$scope 里面的值可以自由更改 (比如说在 Angular 的控制器(Controller)里面)。比如说有这样一常简单的 Angu"><meta name="twitter:image" content="http://cn.vuejs.org/images/data.png"><link rel="shortcut icon" href="/favicon.png"><link rel="icon" type="image/png" href="/img/logo.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/img/logo.png"><title>Angular React Vue 数据驱动实现方式的区别及性能</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/rtl.css"></head><body class="max-width mx-auto px3 ltr"><div id="header-post"><a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")' style="display:none"><i class="fas fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Writing</a></li><li><a href="http://github.com/Yanjiie">Projects</a></li><li><a href="/categories/生活">Lifestyle</a></li><li><a href="/categories/技术">Technology</a></li><li><a href="/about/">Who Am I</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="/2018/01/12/在-Weex-中使用国际化/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle()' onmouseout='$("#i-prev").toggle()'></i></a></li><li><a class="icon" href="/2017/11/24/Weex-的图片加载方案/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle()' onmouseout='$("#i-next").toggle()'></i></a></li><li><a class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fas fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id="i-prev" class="info" style="display:none">Previous post</span> <span id="i-next" class="info" style="display:none">Next post</span> <span id="i-top" class="info" style="display:none">Back to top</span> <span id="i-share" class="info" style="display:none">Share post</span></span><br><div id="share" style="display:none"><ul><li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/"><i class="fab fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/&text=Angular React Vue 数据驱动实现方式的区别及性能"><i class="fab fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/&title=Angular React Vue 数据驱动实现方式的区别及性能"><i class="fab fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/&is_video=false&description=Angular React Vue 数据驱动实现方式的区别及性能"><i class="fab fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Angular React Vue 数据驱动实现方式的区别及性能&body=Check out this article: http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/"><i class="fas fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/&title=Angular React Vue 数据驱动实现方式的区别及性能"><i class="fab fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/&title=Angular React Vue 数据驱动实现方式的区别及性能"><i class="fab fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/&title=Angular React Vue 数据驱动实现方式的区别及性能"><i class="fab fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/&title=Angular React Vue 数据驱动实现方式的区别及性能"><i class="fab fa-digg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/&name=Angular React Vue 数据驱动实现方式的区别及性能&description=&lt;h1 id=&#34;Angular-js-1-的数据驱动实现方式：&#34;&gt;&lt;a href=&#34;#Angular-js-1-的数据驱动实现方式：&#34; class=&#34;headerlink&#34; title=&#34;Angular.js 1 的数据驱动实现方式：&#34;&gt;&lt;/a&gt;Angular.js 1 的数据驱动实现方式：&lt;/h1&gt;&lt;h2 id=&#34;Angular-使用的是脏检查-Dirty-Check-机制。&#34;&gt;&lt;a href=&#34;#Angular-使用的是脏检查-Dirty-Check-机制。&#34; class=&#34;headerlink&#34; title=&#34;Angular 使用的是脏检查( Dirty Check )机制。&#34;&gt;&lt;/a&gt;Angular 使用的是脏检查( Dirty Check )机制。&lt;/h2&gt;&lt;p&gt;Angular 视图模板里,读取数据有一个叫 &lt;code&gt;$scope&lt;/code&gt; 的上下文,可以就认为它是一个存储数据的JS对象, 里面放了各种视图模板需要访问的数据/函数。&lt;code&gt;$scope&lt;/code&gt; 里面的值可以自由更改 (比如说在 Angular 的控制器(Controller)里面)。&lt;/p&gt;&lt;p&gt;比如说有这样一常简单的 Angular 应用 (模板中引用了 &lt;code&gt;$scope&lt;/code&gt; 里的 &lt;code&gt;title&lt;/code&gt; 数据, 同时绑定了 &lt;code&gt;onclick&lt;/code&gt; 事件修改 &lt;code&gt;title&lt;/code&gt; 数据):&lt;/p&gt;&lt;figure class=&#34;highlight html&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;undefined&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;undefined&#34;&gt;    var testApp = angular.module(&#39;testApp&#39;, []);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;undefined&#34;&gt;    testApp.controller(&#39;TestController&#39;, function ($scope) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;undefined&#34;&gt;        $scope.title = &#39;test title&#39;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;undefined&#34;&gt;        $scope.onDIVClick = function () &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;undefined&#34;&gt;            $scope.title = &#39;another title&#39;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;undefined&#34;&gt;        &amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;undefined&#34;&gt;    &amp;#125;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;undefined&#34;&gt;&lt;/span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;div&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;ng-app&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&#34;testApp&#34;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;ng-controller&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&#34;TestController&#34;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;ng-click&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&#34;onDIVClick()&#34;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#123;&amp;#123;title&amp;#125;&amp;#125;  &lt;span class=&#34;comment&#34;&gt;&amp;lt;!-- 显示为: test title --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;"><i class="fab fa-tumblr" aria-hidden="true"></i></a></li></ul></div><div id="toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Angular-js-1-的数据驱动实现方式："><span class="toc-number">1.</span> <span class="toc-text">Angular.js 1 的数据驱动实现方式：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Angular-使用的是脏检查-Dirty-Check-机制。"><span class="toc-number">1.1.</span> <span class="toc-text">Angular 使用的是脏检查( Dirty Check )机制。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-js-的数据驱动实现方式："><span class="toc-number">2.</span> <span class="toc-text">Vue.js 的数据驱动实现方式：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-使用的是依赖收集。（基础-——-getter-setter）"><span class="toc-number">2.1.</span> <span class="toc-text">Vue 使用的是依赖收集。（基础 —— getter/setter）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Watcher"><span class="toc-number">2.1.1.</span> <span class="toc-text">Watcher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖收集"><span class="toc-number">2.1.2.</span> <span class="toc-text">依赖收集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-js-的数据驱动实现方式"><span class="toc-number">2.2.</span> <span class="toc-text">React.js 的数据驱动实现方式</span></a></li></ol></li></ol></div></span></div><div class="content index my4"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Angular React Vue 数据驱动实现方式的区别及性能</h1><div class="meta"><span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">蓝小胖</span></span><div class="postdate"><time datetime="2017-12-29T07:05:44.000Z" itemprop="datePublished">2017-12-29</time></div><div class="article-tag"><i class="fas fa-tag"></i> <a class="tag-link" href="/tags/JavaScript/">JavaScript</a></div></div></header><div class="content" itemprop="articleBody"><h1 id="Angular-js-1-的数据驱动实现方式："><a href="#Angular-js-1-的数据驱动实现方式：" class="headerlink" title="Angular.js 1 的数据驱动实现方式："></a>Angular.js 1 的数据驱动实现方式：</h1><h2 id="Angular-使用的是脏检查-Dirty-Check-机制。"><a href="#Angular-使用的是脏检查-Dirty-Check-机制。" class="headerlink" title="Angular 使用的是脏检查( Dirty Check )机制。"></a>Angular 使用的是脏检查( Dirty Check )机制。</h2><p>Angular 视图模板里,读取数据有一个叫 <code>$scope</code> 的上下文,可以就认为它是一个存储数据的JS对象, 里面放了各种视图模板需要访问的数据/函数。<code>$scope</code> 里面的值可以自由更改 (比如说在 Angular 的控制器(Controller)里面)。</p><p>比如说有这样一常简单的 Angular 应用 (模板中引用了 <code>$scope</code> 里的 <code>title</code> 数据, 同时绑定了 <code>onclick</code> 事件修改 <code>title</code> 数据):</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    var testApp = angular.module('testApp', []);</span></span><br><span class="line"><span class="undefined">    testApp.controller('TestController', function ($scope) &#123;</span></span><br><span class="line"><span class="undefined">        $scope.title = 'test title';</span></span><br><span class="line"><span class="undefined">        $scope.onDIVClick = function () &#123;</span></span><br><span class="line"><span class="undefined">            $scope.title = 'another title';</span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-app</span>=<span class="string">"testApp"</span> <span class="attr">ng-controller</span>=<span class="string">"TestController"</span> <span class="attr">ng-click</span>=<span class="string">"onDIVClick()"</span>&gt;</span></span><br><span class="line">    &#123;&#123;title&#125;&#125;  <span class="comment">&lt;!-- 显示为: test title --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>然后点击 div 触发事件, 就会调用 <code>$scope.onDIVClick</code>, 修改了 <code>title</code> 数据, 然后视图就更新了 (内容变为了 <code>another title</code>)。</p><p>==这一步DOM更新是怎么做到的?==</p><p>答案是, Angular 不监听数据更新, 数据发生任何改变时 Angular 都不理睬, 它只是找了一个恰当的时机, 遍历所有的DOM更新方法, 从被修改过任意次的 <code>$scope</code> 数据中尝试更新DO (这里这个”恰当的时机”就是click事件处理结束时)。</p><p><strong>Angular 脏检查实现</strong></p><ul><li>首先, <code>$watch</code>: Angular 在解析视图模板时, 会找出其中的数据绑定, 以及对应的更新DOM的方式, (比如说这里的 <code>Angular React Vue 数据驱动实现方式的区别及性能</code>, 解析出值表达式为 <code>$scope.title</code>, 更新DOM方式为添加表达式的结果到文字内容区), 然后通过 <code>$scope.$watch</code> 将这一绑定注册到当前 <code>$scope</code> 上下文的更新响应操作里</li><li>然后, <code>$apply</code>: 可能更新数据时(比如事件响应函数里), Angular 调用 <code>$scope.$apply(expression)</code> 处理操作函数, <code>$apply(...)</code> 会在处理完成后调用 <code>$scope.$digest()</code></li><li><code>$digest</code>: 在这一函数里, Angular 正式执行数据到视图的查找以及更新操作:<ul><li><code>$digest</code> 每一个循环里会从根作用域( <code>$rootScope</code> )开始(以深度优先方式)遍历所有的 <code>$scope</code> 注册的 <code>$watch</code> 响应操作。对每一个 <code>$watch</code> 响应, 取出数据绑定的值表达式, 求出值, 与上一次的求值作比较, 求值不一样 则取出DOM更新函数, 更新视图</li><li>上一步里, 循环开始时置 <code>dirty = false</code>。只要有任何一个 <code>$watch</code> 响应的值发生了更新, 则当前 <code>$digest</code> 循环置 <code>dirty = true</code></li><li>每次循环结束后, 只要 <code>dirty === true</code> 依然成立, 重新开始新的一轮 <code>$digest</code> 检查循环, 直到 <code>dirty === false</code> (这就是为什么这个实现机制叫做脏检查( Dirty Check ))</li></ul></li></ul><p><strong>脏检查会执行几次?</strong></p><p>即便 $watch 响应里没有更新任何数据, 通常来说脏检查循环也会执行两次, 比如在这个例子里面就是的:</p><ul><li>首先, 在执行 <code>$digest</code> 开始脏检查循环前, click事件触发调用的 <code>onDIVClick</code> 中已经更新了 <code>titl</code>e 数据</li><li>进入第一遍脏检查循环后, <code>Angular React Vue 数据驱动实现方式的区别及性能</code> 对应的 <code>$watch</code> 响应中, 值表达式之前的结果是 <code>&#39;test title&#39;</code>, 现在由于数据已经发生了改变, 新的结果变成了 <code>&#39;another title&#39;</code>, 第一遍循环, <code>dirty</code> 置为 <code>true</code>, 进入下一遍循环</li><li>进入第二便脏检查循环后, 值表达式两次结果均为 <code>&#39;another title&#39;</code>, 没有变化, <code>dirty</code> 为 <code>false</code>。结束脏检查</li></ul><p>所以什么时候脏检查循环只会执行一遍呢? 就是 <code>$apply(...)</code> 处理的操作中没有数据更新操作 (这里描述并不准确, 实际上是否有数据更新跟脏循环执行次数不一定相关, 等会再说)。也就是说, 移除 <code>onDIVClick</code> 里的 <code>title</code> 赋值操作, 脏检查循环就只会执行一次。</p><p>那么, 什么时候脏检查会执行无数次呢? 很简单, 在 <code>$watch</code> 响应的值表达式中中每次都返回新的数据。</p><p>==推荐阅读：==</p><ol><li><a href="http://blog.yunfei.me/blog/angular-dirty-check.html" target="_blank" rel="noopener">Angular 脏检查机制研究</a></li><li><a href="https://github.com/xufei/blog/issues/10" target="_blank" rel="noopener">Angular沉思录（一）数据绑定</a></li></ol><h1 id="Vue-js-的数据驱动实现方式："><a href="#Vue-js-的数据驱动实现方式：" class="headerlink" title="Vue.js 的数据驱动实现方式："></a>Vue.js 的数据驱动实现方式：</h1><h2 id="Vue-使用的是依赖收集。（基础-——-getter-setter）"><a href="#Vue-使用的是依赖收集。（基础-——-getter-setter）" class="headerlink" title="Vue 使用的是依赖收集。（基础 —— getter/setter）"></a>Vue 使用的是依赖收集。（基础 —— getter/setter）</h2><p>同样是实现了双向绑定，但 Vue 使用的方法与 Angular 却完全不同。Vue 的文档中是这样描述的：</p><blockquote><p>把一个普通对象传给 Vue 实例作为它的 data 选项，Vue.js 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。这是 ES5 特性，不能打补丁实现，这便是为什么 Vue.js 不支持 IE8 及更低版本。</p></blockquote><p><code>getter/setter</code> 使得开发者有机会在对象属性取值和赋值的时候进行自定义操作，响应系统便是基于这个特性实现的。</p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p><code>Watcher</code> 是 Vue 核心。每个 <code>Watcher</code> 都拥有一个自己的表达式，<code>Watcher</code> 的作用就是维护这个表达式依赖的数据项，并在数据项更新的时候更新表达式的值。其实从 Vue 的实现来讲，<code>Watcher</code> 应该被叫做 <code>Listener</code>或 <code>Subscriber</code> 更加合适。</p><blockquote><p>模板中每个指令/数据绑定都有一个对应的 watcher 对象，在计算过程中它把属性记录为依赖。之后当依赖的 setter 被调用时，会触发 watcher 重新计算 ，也就会导致它的关联指令更新 DOM。<br><img src="http://cn.vuejs.org/images/data.png" alt=""></p></blockquote><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>依赖收集是通过 <code>property</code> 的 <code>getter</code> 完成的，依赖收集的过程涉及到 Vue 的三类对象：<code>Watcher</code>、<code>Dep</code> 和 <code>Observer</code>。其中 <code>Observer</code> 负责将数据项转化为响应式对象，而 <code>Dep</code> 则用来描述 <code>Watcher</code> 和 <code>Observer</code> 的依赖关系。</p><p>Vue 中，每个 <code>Observer</code> 对应一个 <code>Dep</code> 对象，而每个 <code>Dep</code> 对象可以对应多个 <code>Watcher</code>，每个 <code>Watcher</code> 也可以对应多个 <code>Dep</code> 对象，从而实现了多对多的依赖关系。</p><p>搞清楚了三类对象，下面就来看看依赖关系到底是怎样建立起来的：</p><ol><li>Vue 实例初始化的过程中，首先，每个数据项都会生成一个 <code>Observer</code>，每个 <code>Observer</code> 又会初始化一个 <code>Dep</code> 实例；</li><li>接下来，模板中的每个指令和数据绑定都会生成一个 <code>Watcher</code> 实例，实例化的过程中，会计算这个 <code>Watcher</code> 对应表达式的值；</li><li>计算开始之前，<code>Watcher</code> 会设置 <code>Dep</code> 的静态属性 <code>Dep.target</code> 指向其自身，开始依赖收集；</li><li>计算表达式的过程中，该 <code>Watcher</code> 依赖的数据项会被访问，从而触发其 <code>getter</code> 中的代码；</li><li>数据项 <code>getter</code> 中会判断 <code>Dep.target</code> 是否存在，若存在则将自身的 <code>Dep</code> 实例保存到 <code>Watcher</code> 的列表中，并在此 <code>Dep</code> 实例中注册 <code>Watcher</code> 为订阅者；</li><li>重复上述过程直至 <code>Watcher</code> 计算结束，<code>Dep.target</code> 被清除，依赖收集完成；</li></ol><p>在依赖关系建立后，每当数据项发生变化（<code>setter</code> 被访问），<code>Observer</code> 会调用其 <code>Dep</code> 实例的 <code>notify</code> 方法，在这个 <code>Dep</code> 实例中注册的 <code>Watcher</code> 将会被通知，并重新进行计算及依赖收集的过程，然后执行相应的回调函数。以上就是完成响应的整个过程。</p><p>==推荐阅读：==</p><ol><li><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">Vue官方文档–深入响应式原理</a></li><li><a href="https://zjy.name/archives/vue-reactive-study.html" target="_blank" rel="noopener">Vue 响应式原理探析</a></li><li><a href="https://segmentfault.com/a/1190000011153487" target="_blank" rel="noopener">深入浅出基于“依赖收集”的响应式原理</a></li></ol><h2 id="React-js-的数据驱动实现方式"><a href="#React-js-的数据驱动实现方式" class="headerlink" title="React.js 的数据驱动实现方式"></a>React.js 的数据驱动实现方式</h2><p>React 本质没有双向绑定概念，算法本质是 diff。通过 dom 的抽象化，在 render 时通过比较 vdom 的差异，再使用原生 api patch 到真实 dom 中。</p></div></article></div><div id="footer-post-container"><div id="footer-post"><div id="nav-footer" style="display:none"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Writing</a></li><li><a href="http://github.com/Yanjiie">Projects</a></li><li><a href="/categories/生活">Lifestyle</a></li><li><a href="/categories/技术">Technology</a></li><li><a href="/about/">Who Am I</a></li></ul></div><div id="toc-footer" style="display:none"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Angular-js-1-的数据驱动实现方式："><span class="toc-number">1.</span> <span class="toc-text">Angular.js 1 的数据驱动实现方式：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Angular-使用的是脏检查-Dirty-Check-机制。"><span class="toc-number">1.1.</span> <span class="toc-text">Angular 使用的是脏检查( Dirty Check )机制。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-js-的数据驱动实现方式："><span class="toc-number">2.</span> <span class="toc-text">Vue.js 的数据驱动实现方式：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-使用的是依赖收集。（基础-——-getter-setter）"><span class="toc-number">2.1.</span> <span class="toc-text">Vue 使用的是依赖收集。（基础 —— getter/setter）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Watcher"><span class="toc-number">2.1.1.</span> <span class="toc-text">Watcher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖收集"><span class="toc-number">2.1.2.</span> <span class="toc-text">依赖收集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-js-的数据驱动实现方式"><span class="toc-number">2.2.</span> <span class="toc-text">React.js 的数据驱动实现方式</span></a></li></ol></li></ol></div><div id="share-footer" style="display:none"><ul><li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/&text=Angular React Vue 数据驱动实现方式的区别及性能"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/&title=Angular React Vue 数据驱动实现方式的区别及性能"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/&is_video=false&description=Angular React Vue 数据驱动实现方式的区别及性能"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Angular React Vue 数据驱动实现方式的区别及性能&body=Check out this article: http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/&title=Angular React Vue 数据驱动实现方式的区别及性能"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/&title=Angular React Vue 数据驱动实现方式的区别及性能"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/&title=Angular React Vue 数据驱动实现方式的区别及性能"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/&title=Angular React Vue 数据驱动实现方式的区别及性能"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yanjiie.me/2017/12/29/Angular React Vue 数据驱动实现方式的区别及性能/&name=Angular React Vue 数据驱动实现方式的区别及性能&description=&lt;h1 id=&#34;Angular-js-1-的数据驱动实现方式：&#34;&gt;&lt;a href=&#34;#Angular-js-1-的数据驱动实现方式：&#34; class=&#34;headerlink&#34; title=&#34;Angular.js 1 的数据驱动实现方式：&#34;&gt;&lt;/a&gt;Angular.js 1 的数据驱动实现方式：&lt;/h1&gt;&lt;h2 id=&#34;Angular-使用的是脏检查-Dirty-Check-机制。&#34;&gt;&lt;a href=&#34;#Angular-使用的是脏检查-Dirty-Check-机制。&#34; class=&#34;headerlink&#34; title=&#34;Angular 使用的是脏检查( Dirty Check )机制。&#34;&gt;&lt;/a&gt;Angular 使用的是脏检查( Dirty Check )机制。&lt;/h2&gt;&lt;p&gt;Angular 视图模板里,读取数据有一个叫 &lt;code&gt;$scope&lt;/code&gt; 的上下文,可以就认为它是一个存储数据的JS对象, 里面放了各种视图模板需要访问的数据/函数。&lt;code&gt;$scope&lt;/code&gt; 里面的值可以自由更改 (比如说在 Angular 的控制器(Controller)里面)。&lt;/p&gt;&lt;p&gt;比如说有这样一常简单的 Angular 应用 (模板中引用了 &lt;code&gt;$scope&lt;/code&gt; 里的 &lt;code&gt;title&lt;/code&gt; 数据, 同时绑定了 &lt;code&gt;onclick&lt;/code&gt; 事件修改 &lt;code&gt;title&lt;/code&gt; 数据):&lt;/p&gt;&lt;figure class=&#34;highlight html&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;undefined&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;undefined&#34;&gt;    var testApp = angular.module(&#39;testApp&#39;, []);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;undefined&#34;&gt;    testApp.controller(&#39;TestController&#39;, function ($scope) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;undefined&#34;&gt;        $scope.title = &#39;test title&#39;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;undefined&#34;&gt;        $scope.onDIVClick = function () &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;undefined&#34;&gt;            $scope.title = &#39;another title&#39;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;undefined&#34;&gt;        &amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;undefined&#34;&gt;    &amp;#125;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;undefined&#34;&gt;&lt;/span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;div&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;ng-app&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&#34;testApp&#34;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;ng-controller&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&#34;TestController&#34;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;ng-click&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&#34;onDIVClick()&#34;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#123;&amp;#123;title&amp;#125;&amp;#125;  &lt;span class=&#34;comment&#34;&gt;&amp;lt;!-- 显示为: test title --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li></ul></div><div id="actions-footer"><a id="menu" class="icon" href="#" onclick='return $("#nav-footer").toggle(),!1'><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a> <a id="toc" class="icon" href="#" onclick='return $("#toc-footer").toggle(),!1'><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a><a id="top" style="display:none" class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></div></div></div><footer id="footer"><div class="footer-left">Copyright &copy; 2018 Yanjiie</div></footer></body></html><link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css"><script src="/lib/jquery/jquery.min.js"></script><script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script><script>FontAwesomeConfig={searchPseudoElements:!0}</script><script src="https://use.fontawesome.com/releases/v5.0.8/js/all.js" data-auto-replace-svg="nest"></script><script src="/js/main.js"></script>